#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "httpx",
#     "pydantic",
#     "pydantic-settings",
# ]
# ///

import asyncio
import httpx
from typing import TypeVar
from pydantic import *
from pydantic_settings import *

T = TypeVar('T', bound=BaseModel)


class Settings(BaseSettings, cli_prog_name="check-homework", cli_parse_args=True, cli_kebab_case=True):
    canvas_url: str = Field(description="Canvas instance URL (e.g., https://canvas.instructure.com)")
    canvas_api_key: str = Field(description="Canvas API access token")


class Course(BaseModel):
    id: int
    name: str
    course_code: str | None = None


class Assignment(BaseModel):
    id: int
    name: str
    due_at: str | None = None


class Notification(BaseModel):
    id: int
    title: str | None = None
    message: str | None = None
    type: str | None = None

    created_at: str | None = None
    updated_at: str | None = None
    workflow_state: str | None = None


class Announcement(BaseModel):
    id: int
    title: str
    message: str | None = None
    read_state: str
    posted_at: str | None = None
    context_name: str | None = None


class TodoItem(BaseModel):
    type: str  # "grading" or "submitting"
    assignment: Assignment | None = None
    html_url: str | None = None
    needs_grading_count: int | None = None
    context_type: str | None = None


class UpcomingEvent(BaseModel):
    id: int | str  # Can be int or string like "assignment_26852"
    title: str
    start_at: str | None = None
    end_at: str | None = None
    context_code: str | None = None
    assignment: Assignment | None = None


class CanvasClient(httpx.AsyncClient):
    def __init__(self, settings: Settings):
        # Remove trailing slash from URL if present
        self.canvas_url = settings.canvas_url.rstrip("/")

        # Set up default headers
        headers = {
            "Authorization": f"Bearer {settings.canvas_api_key}",
            "Accept": "application/json",
        }

        # Initialize AsyncClient with headers
        super().__init__(headers=headers)

    async def _get_list(self, endpoint: str, model_class: type[T], params: dict | None = None) -> list[T]:
        """Helper method to fetch a list of items and convert to domain objects"""
        response = await self.get(endpoint, params=params)
        response.raise_for_status()
        return [model_class.model_validate(item) for item in response.json()]

    async def get_courses(self, enrollment_state: str = "active") -> list[Course]:
        endpoint = f"{self.canvas_url}/api/v1/courses"
        params = {
            "enrollment_state": enrollment_state,
            "per_page": 100,
        }
        return await self._get_list(endpoint, Course, params)

    async def get_assignments(self, course_id: int, bucket: str = "upcoming") -> list[Assignment]:
        endpoint = f"{self.canvas_url}/api/v1/courses/{course_id}/assignments"
        params = {
            "per_page": 100,
            "bucket": bucket
        }
        return await self._get_list(endpoint, Assignment, params)

    async def get_notifications(self, per_page: int = 10) -> list[Notification]:
        """Get user's activity stream notifications"""
        endpoint = f"{self.canvas_url}/api/v1/users/self/activity_stream"
        params = {"per_page": per_page}
        return await self._get_list(endpoint, Notification, params)

    async def get_announcements(self, context_codes: list[str] | None = None, per_page: int = 10) -> list[Announcement]:
        """Get announcements for the current user

        Args:
            context_codes: Optional list of context codes (e.g., ['course_123', 'course_456'])
            per_page: Number of announcements to return per page
        """
        endpoint = f"{self.canvas_url}/api/v1/announcements"
        params = {"per_page": per_page}
        if context_codes:
            params["context_codes[]"] = context_codes
        return await self._get_list(endpoint, Announcement, params)

    async def get_user_todos(self) -> list[TodoItem]:
        """Get the current user's todo items"""
        endpoint = f"{self.canvas_url}/api/v1/users/self/todo"
        return await self._get_list(endpoint, TodoItem)

    async def get_missing_submissions(self, user_id: str = "self") -> list[Assignment]:
        """Get missing submissions for a user

        Args:
            user_id: User ID or 'self' for the current user
        """
        endpoint = f"{self.canvas_url}/api/v1/users/{user_id}/missing_submissions"
        return await self._get_list(endpoint, Assignment)

    async def get_upcoming_events(self) -> list[UpcomingEvent]:
        """Get upcoming events for the current user"""
        endpoint = f"{self.canvas_url}/api/v1/users/self/upcoming_events"
        return await self._get_list(endpoint, UpcomingEvent)


async def main() -> None:
    try:
        settings = Settings()
        async with CanvasClient(settings) as client:
            # Test user todos
            print("=== TODO ITEMS ===")
            todos = await client.get_user_todos()
            for todo in todos:
                print(f"[{todo.type}] {todo.assignment.name if todo.assignment else 'N/A'}")
                print(f"  URL: {todo.html_url}")
                if todo.needs_grading_count:
                    print(f"  Needs grading: {todo.needs_grading_count}")
                print()

            # Test missing submissions
            print("\n=== MISSING SUBMISSIONS ===")
            missing = await client.get_missing_submissions()
            for assignment in missing:
                print(f"{assignment.name}")
                print(f"  Due: {assignment.due_at}")
                print()

            # Test upcoming events
            print("\n=== UPCOMING EVENTS ===")
            upcoming = await client.get_upcoming_events()
            for event in upcoming:
                print(f"{event.title}")
                print(f"  Start: {event.start_at}")
                print(f"  Context: {event.context_code}")
                if event.assignment:
                    print(f"  Assignment: {event.assignment.name}")
                print()

            # Test notifications
            print("\n=== NOTIFICATIONS ===")
            notifications = await client.get_notifications(per_page=5)
            for notification in notifications:
                print(f"[{notification.type}] {notification.title}")
                print(f"  Created: {notification.created_at}")
                print()

            # Get courses first to use as context for announcements
            courses = await client.get_courses()
            context_codes = [f"course_{course.id}" for course in courses]

            # Test announcements with course context codes
            print("\n=== ANNOUNCEMENTS ===")
            announcements = await client.get_announcements(context_codes=context_codes, per_page=5)
            for announcement in announcements:
                print(f"{announcement.title}")
                print(f"  Posted: {announcement.posted_at}")
                print(f"  Read: {announcement.read_state}")
                print()

            # Test courses and assignments
            print("\n=== COURSES & ASSIGNMENTS ===")
            for course in courses:
                print(f"{course.name} (ID: {course.id})")
                assignments = await client.get_assignments(course.id)
                for assignment in assignments:
                    print(f"\t{assignment.name} {assignment.due_at}")
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    asyncio.run(main())
