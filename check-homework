#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "httpx",
#     "pydantic",
#     "pydantic-settings",
#     "rich",
# ]
# ///

import asyncio
import httpx
from datetime import datetime, timezone
from typing import TypeVar, AsyncIterator, Literal
from pydantic import *
from pydantic_settings import *
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

T = TypeVar('T', bound=BaseModel)


class Settings(BaseSettings, cli_prog_name="check-homework", cli_parse_args=True, cli_kebab_case=True):
    canvas_url: str = Field(description="Canvas instance URL (e.g., https://canvas.instructure.com)")
    canvas_api_key: str = Field(description="Canvas API access token")


class Course(BaseModel):
    id: int
    name: str
    course_code: str | None = None


class Assignment(BaseModel):
    id: int
    name: str
    due_at: datetime | None = None


class Quiz(BaseModel):
    id: str
    title: str
    due_at: datetime | None = None


class TodoItem(BaseModel):
    type: Literal["grading", "submitting"]
    assignment: Assignment | Quiz | None = None
    html_url: str | None = None
    needs_grading_count: int | None = None
    context_type: Literal["Course", "Group"] | None = None
    course_id: int


class UpcomingEvent(BaseModel):
    id: int | str  # Can be int or string like "assignment_26852"
    title: str
    start_at: datetime | None = None
    end_at: datetime | None = None
    context_code: str | None = None
    assignment: Assignment | None = None


class CanvasClient(httpx.AsyncClient):
    def __init__(self, settings: Settings):
        headers = {
            "Authorization": f"Bearer {settings.canvas_api_key}",
            "Accept": "application/json",
        }

        super().__init__(base_url=settings.canvas_url, headers=headers)

    async def _get_iterator(self, endpoint: str, model_class: type[T], per_page: int = 10, **kwargs) -> AsyncIterator[T]:
        """Helper method to fetch and yield items with pagination support"""
        url = endpoint
        params = {"per_page": per_page, **kwargs}

        # Follow pagination links until there are no more pages
        while url:
            response = await self.get(url, params=params if url == endpoint else None)
            response.raise_for_status()

            page_items = response.json()
            for item in page_items:
                yield model_class.model_validate(item)

            url = response.links.get('next', {}).get('url')

    async def get_courses(self, enrollment_state: str = "active") -> AsyncIterator[Course]:
        endpoint = "/api/v1/courses"
        async for item in self._get_iterator(endpoint, Course, enrollment_state=enrollment_state):
            yield item

    async def get_todos(self, user_id: str = "self") -> AsyncIterator[TodoItem]:
        """Get the current user's todo items"""
        endpoint = f"/api/v1/users/{user_id}/todo"
        async for item in self._get_iterator(endpoint, TodoItem):
            yield item

    async def get_missing_submissions(self, user_id: str = "self") -> AsyncIterator[Assignment]:
        """Get missing submissions for a user."""
        endpoint = f"/api/v1/users/{user_id}/missing_submissions"
        async for item in self._get_iterator(endpoint, Assignment):
            yield item

    async def get_upcoming_events(self, user_id: str = "self") -> AsyncIterator[UpcomingEvent]:
        """Get upcoming events for the current user"""
        endpoint = f"/api/v1/users/{user_id}/upcoming_events"
        async for item in self._get_iterator(endpoint, UpcomingEvent):
            yield item


def get_relative_time(dt: datetime | None) -> str:
    """Get a human-readable relative time string."""
    if not dt:
        return "N/A"

    now = datetime.now(timezone.utc)
    delta = dt - now
    days = delta.days

    if days < 0:
        return f"{abs(days)} days ago" if abs(days) != 1 else "1 day ago"
    elif days == 0:
        return "Today"
    elif days == 1:
        return "Tomorrow"
    else:
        return f"in {days} days"


async def display_todos(console: Console, client: CanvasClient) -> None:
    """Display TODO items in a Rich table."""
    table = Table(title="TODO Items", show_header=True, header_style="bold cyan")
    table.add_column("Type", style="dim")
    table.add_column("Assignment")
    table.add_column("URL", style="blue")

    async for todo in client.get_todos():
        type_color = "cyan" if todo.type == "submitting" else "magenta"
        assignment_name = todo.assignment.name if todo.assignment else "N/A"

        table.add_row(
            f"[{type_color}]{todo.type}[/{type_color}]",
            assignment_name,
            todo.html_url or "N/A"
        )

    console.print(Panel(table, border_style="cyan"))


async def display_missing_assignments(console: Console, client: CanvasClient) -> None:
    """Display missing assignments in a Rich table."""
    table = Table(title="Missing Assignments", show_header=True, header_style="bold red")
    table.add_column("Assignment")
    table.add_column("Due Date")
    table.add_column("Status", style="dim")

    async for assignment in client.get_missing_submissions():
        relative = get_relative_time(assignment.due_at)
        due_date_str = assignment.due_at.strftime("%Y-%m-%d %H:%M") if assignment.due_at else "N/A"

        # Color code based on how overdue
        if assignment.due_at:
            days_overdue = (datetime.now(timezone.utc) - assignment.due_at).days
            if days_overdue > 7:
                name_style = "bold red"
            elif days_overdue > 0:
                name_style = "red"
            else:
                name_style = "yellow"
        else:
            name_style = "white"

        table.add_row(
            f"[{name_style}]{assignment.name}[/{name_style}]",
            due_date_str,
            relative
        )

    console.print(Panel(table, border_style="red"))


async def display_upcoming_events(console: Console, client: CanvasClient) -> None:
    """Display upcoming events in a Rich table."""
    table = Table(title="Upcoming Events", show_header=True, header_style="bold green")
    table.add_column("Event")
    table.add_column("Start Date")
    table.add_column("When", style="dim")
    table.add_column("Context", style="dim")

    async for event in client.get_upcoming_events():
        relative = get_relative_time(event.start_at)
        start_date_str = event.start_at.strftime("%Y-%m-%d %H:%M") if event.start_at else "N/A"

        # Color code based on how soon
        if event.start_at:
            days_until = (event.start_at - datetime.now(timezone.utc)).days
            if days_until <= 1:
                title_style = "bold yellow"
            elif days_until <= 7:
                title_style = "yellow"
            else:
                title_style = "green"
        else:
            title_style = "white"

        table.add_row(
            f"[{title_style}]{event.title}[/{title_style}]",
            start_date_str,
            relative,
            event.context_code or "N/A"
        )

    console.print(Panel(table, border_style="green"))


async def main() -> None:
    console = Console()

    try:
        settings = Settings()
        async with CanvasClient(settings) as client:
            await display_todos(console, client)
            console.print()  # Add spacing between panels

            await display_missing_assignments(console, client)
            console.print()

            await display_upcoming_events(console, client)
    except Exception as e:
        console.print(f"[bold red]Error:[/bold red] {e}")


if __name__ == "__main__":
    asyncio.run(main())
