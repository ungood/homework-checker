#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "httpx",
#     "pydantic",
#     "pydantic-settings",
#     "rich",
#     "humanize",
# ]
# ///

import asyncio
import httpx
import humanize
import json
import logging
import re
import sys
from datetime import datetime, timezone
from typing import TypeVar, AsyncIterator, Literal
from pydantic import *
from pydantic_settings import *
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

T = TypeVar('T', bound=BaseModel)

logger = logging.getLogger(__name__)


class Settings(BaseSettings, cli_prog_name="check-homework", cli_parse_args=True, cli_kebab_case=True):
    canvas_url: str = Field(description="Canvas instance URL (e.g., https://canvas.instructure.com)")
    canvas_api_key: str = Field(description="Canvas API access token")
    debug: bool = Field(default=False, description="Enable debug logging")


class Course(BaseModel):
    id: int
    name: str
    course_code: str | None = None


class Assignment(BaseModel):
    id: int
    name: str
    due_at: datetime | None = None
    course_id: int | None = None
    has_submitted_submissions: bool = False


class Quiz(BaseModel):
    id: str
    title: str
    due_at: datetime | None = None


class TodoItem(BaseModel):
    type: Literal["grading", "submitting"]
    assignment: Assignment | Quiz | None = None
    html_url: str | None = None
    needs_grading_count: int | None = None
    context_type: Literal["Course", "Group"] | None = None
    course_id: int


class UpcomingEvent(BaseModel):
    id: int | str  # Can be int or string like "assignment_26852"
    title: str
    start_at: datetime | None = None
    end_at: datetime | None = None
    context_code: str | None = None
    assignment: Assignment | None = None


class CanvasClient(httpx.AsyncClient):
    def __init__(self, settings: Settings):
        headers = {
            "Authorization": f"Bearer {settings.canvas_api_key}",
            "Accept": "application/json",
        }

        super().__init__(base_url=settings.canvas_url, headers=headers)

    async def _get_iterator(self, endpoint: str, model_class: type[T], per_page: int = 10, **kwargs) -> AsyncIterator[T]:
        """Helper method to fetch and yield items with pagination support"""
        url = endpoint
        params = {"per_page": per_page, **kwargs}

        # Follow pagination links until there are no more pages
        while url:
            response = await self.get(url, params=params if url == endpoint else None)
            response.raise_for_status()

            page_items = response.json()
            logger.debug(f"Received JSON response from {url}:\n{json.dumps(page_items, indent=2)}")

            for item in page_items:
                yield model_class.model_validate(item)

            url = response.links.get('next', {}).get('url')

    async def get_courses(self, enrollment_state: str = "active") -> AsyncIterator[Course]:
        endpoint = "/api/v1/courses"
        async for item in self._get_iterator(endpoint, Course, enrollment_state=enrollment_state):
            yield item

    async def get_todos(self, user_id: str = "self") -> AsyncIterator[TodoItem]:
        """Get the current user's todo items"""
        endpoint = f"/api/v1/users/{user_id}/todo"
        async for item in self._get_iterator(endpoint, TodoItem):
            yield item

    async def get_missing_submissions(self, user_id: str = "self") -> AsyncIterator[Assignment]:
        """Get missing submissions for a user."""
        endpoint = f"/api/v1/users/{user_id}/missing_submissions"
        async for item in self._get_iterator(endpoint, Assignment):
            yield item

    async def get_upcoming_events(self, user_id: str = "self") -> AsyncIterator[UpcomingEvent]:
        """Get upcoming events for the current user"""
        endpoint = f"/api/v1/users/{user_id}/upcoming_events"
        async for item in self._get_iterator(endpoint, UpcomingEvent):
            yield item


def get_relative_time(dt: datetime | None) -> str:
    """Get a human-readable relative time string."""
    if not dt:
        return "N/A"
    return humanize.naturaltime(dt)


def parse_course_id(context_code: str | None) -> int | None:
    """Extract course ID from context code like 'course_1176'."""
    if not context_code or not context_code.startswith("course_"):
        return None
    try:
        return int(context_code.split("_")[1])
    except (IndexError, ValueError):
        return None


class SanitizedTable(Table):
    """Table subclass that automatically sanitizes text to prevent formatting issues."""

    @staticmethod
    def sanitize_text(text: str) -> str:
        """Remove emojis, newlines and normalize whitespace in text for table display."""
        if not text:
            return text

        # Remove emojis and other special Unicode characters
        # This pattern covers most emoji ranges
        emoji_pattern = re.compile(
            "["
            "\U0001F600-\U0001F64F"  # emoticons
            "\U0001F300-\U0001F5FF"  # symbols & pictographs
            "\U0001F680-\U0001F6FF"  # transport & map symbols
            "\U0001F1E0-\U0001F1FF"  # flags (iOS)
            "\U00002702-\U000027B0"  # dingbats
            "\U000024C2-\U0001F251"  # enclosed characters
            "\U0001F900-\U0001F9FF"  # supplemental symbols
            "\U0001FA00-\U0001FAFF"  # extended symbols
            "]+",
            flags=re.UNICODE
        )
        text = emoji_pattern.sub('', text)

        # Replace newlines and multiple spaces with single space, and trim
        return ' '.join(text.split()).strip()

    def add_row(self, *renderables, **kwargs):
        """Override add_row to sanitize text renderables."""
        sanitized = []
        for item in renderables:
            if isinstance(item, str):
                sanitized.append(self.sanitize_text(item))
            else:
                sanitized.append(item)
        return super().add_row(*sanitized, **kwargs)


class HomeworkConsole(Console):
    """Console for displaying homework information."""

    def __init__(self, client: CanvasClient, courses: dict[int, str]):
        super().__init__()
        self.client = client
        self.courses = courses

    async def display_todos(self) -> None:
        """Display TODO items in a Rich table."""
        table = SanitizedTable(title="TODO Items", show_header=True, header_style="bold cyan")
        table.add_column("Date")
        table.add_column("Course", style="dim")
        table.add_column("Title")

        async for todo in self.client.get_todos():
            # Skip todos that are "submitting" type but already have submissions
            if todo.type == "submitting" and todo.assignment and todo.assignment.has_submitted_submissions:
                continue

            course_name = self.courses.get(todo.course_id, "Unknown")
            assignment_name = todo.assignment.name if todo.assignment else "N/A"

            # Extract due date from assignment
            due_at = todo.assignment.due_at if todo.assignment else None
            relative = get_relative_time(due_at)
            due_date_str = due_at.strftime("%Y-%m-%d") if due_at else "N/A"
            date_with_relative = f"{due_date_str} ({relative})"

            table.add_row(
                date_with_relative,
                course_name,
                assignment_name
            )

        self.print(Panel(table, border_style="cyan"))

    async def display_missing_assignments(self) -> None:
        """Display missing assignments in a Rich table."""
        table = SanitizedTable(title="Missing Assignments", show_header=True, header_style="bold red")
        table.add_column("Date")
        table.add_column("Course", style="dim")
        table.add_column("Title")

        async for assignment in self.client.get_missing_submissions():
            course_name = self.courses.get(assignment.course_id, "Unknown") if assignment.course_id else "Unknown"
            relative = get_relative_time(assignment.due_at)
            due_date_str = assignment.due_at.strftime("%Y-%m-%d") if assignment.due_at else "N/A"
            date_with_relative = f"{due_date_str} ({relative})"

            # Color code based on how overdue
            if assignment.due_at:
                days_overdue = (datetime.now(timezone.utc) - assignment.due_at).days
                if days_overdue > 7:
                    name_style = "bold red"
                elif days_overdue > 0:
                    name_style = "red"
                else:
                    name_style = "yellow"
            else:
                name_style = "white"

            table.add_row(
                date_with_relative,
                course_name,
                f"[{name_style}]{assignment.name}[/{name_style}]"
            )

        self.print(Panel(table, border_style="red"))

    async def display_upcoming_events(self) -> None:
        """Display upcoming events in a Rich table."""
        table = SanitizedTable(title="Upcoming Events", show_header=True, header_style="bold green")
        table.add_column("Date")
        table.add_column("Course", style="dim")
        table.add_column("Title")

        async for event in self.client.get_upcoming_events():
            course_id = parse_course_id(event.context_code)
            course_name = self.courses.get(course_id, "Unknown") if course_id else "Unknown"
            relative = get_relative_time(event.start_at)
            start_date_str = event.start_at.strftime("%Y-%m-%d") if event.start_at else "N/A"
            date_with_relative = f"{start_date_str} ({relative})"

            # Color code based on how soon
            if event.start_at:
                days_until = (event.start_at - datetime.now(timezone.utc)).days
                if days_until <= 1:
                    title_style = "bold yellow"
                elif days_until <= 7:
                    title_style = "yellow"
                else:
                    title_style = "green"
            else:
                title_style = "white"

            table.add_row(
                date_with_relative,
                course_name,
                f"[{title_style}]{event.title}[/{title_style}]"
            )

        self.print(Panel(table, border_style="green"))


async def main() -> None:
    console = Console()

    try:
        settings = Settings()

        # Configure logging to output to stderr
        logging.basicConfig(
            level=logging.WARNING,  # Set root logger to WARNING to suppress third-party logs
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            stream=sys.stderr
        )

        # Set our logger to DEBUG or INFO based on settings
        logger.setLevel(logging.DEBUG if settings.debug else logging.INFO)

        async with CanvasClient(settings) as client:
            # Fetch courses first and create lookup dictionary
            courses = {course.id: course.name async for course in client.get_courses()}

            # Create homework console and display all sections
            hw_console = HomeworkConsole(client, courses)

            await hw_console.display_todos()
            hw_console.print()  # Add spacing between panels

            await hw_console.display_missing_assignments()
            hw_console.print()

            await hw_console.display_upcoming_events()
    except Exception as e:
        console.print(f"[bold red]Error:[/bold red] {e}")


if __name__ == "__main__":
    asyncio.run(main())
