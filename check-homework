#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "httpx",
#     "pydantic",
#     "pydantic-settings",
# ]
# ///

import asyncio
import httpx
from typing import TypeVar, AsyncIterator
from pydantic import *
from pydantic_settings import *

T = TypeVar('T', bound=BaseModel)


class Settings(BaseSettings, cli_prog_name="check-homework", cli_parse_args=True, cli_kebab_case=True):
    canvas_url: str = Field(description="Canvas instance URL (e.g., https://canvas.instructure.com)")
    canvas_api_key: str = Field(description="Canvas API access token")


class Course(BaseModel):
    id: int
    name: str
    course_code: str | None = None


class Assignment(BaseModel):
    id: int
    name: str
    due_at: str | None = None


class Notification(BaseModel):
    id: int
    title: str | None = None
    message: str | None = None
    type: str | None = None

    created_at: str | None = None
    updated_at: str | None = None
    workflow_state: str | None = None


class Announcement(BaseModel):
    id: int
    title: str
    message: str | None = None
    read_state: str
    posted_at: str | None = None
    context_name: str | None = None


class TodoItem(BaseModel):
    type: str  # "grading" or "submitting"
    assignment: Assignment | None = None
    html_url: str | None = None
    needs_grading_count: int | None = None
    context_type: str | None = None


class UpcomingEvent(BaseModel):
    id: int | str  # Can be int or string like "assignment_26852"
    title: str
    start_at: str | None = None
    end_at: str | None = None
    context_code: str | None = None
    assignment: Assignment | None = None


class CanvasClient(httpx.AsyncClient):
    def __init__(self, settings: Settings):
        # Set up default headers
        headers = {
            "Authorization": f"Bearer {settings.canvas_api_key}",
            "Accept": "application/json",
        }

        super().__init__(base_url=settings.canvas_url, headers=headers)

    async def _get_iterator(self, endpoint: str, model_class: type[T], per_page: int = 10, **kwargs) -> AsyncIterator[T]:
        """Helper method to fetch and yield items with pagination support"""
        url = endpoint
        params = {"per_page": per_page, **kwargs}

        # Follow pagination links until there are no more pages
        while url:
            response = await self.get(url, params=params if url == endpoint else None)
            response.raise_for_status()

            # Yield items from this page
            page_items = response.json()
            for item in page_items:
                yield model_class.model_validate(item)

            # Use httpx's built-in Link header parsing
            url = response.links.get('next', {}).get('url')

    async def get_courses(self, enrollment_state: str = "active") -> AsyncIterator[Course]:
        endpoint = "/api/v1/courses"
        async for item in self._get_iterator(endpoint, Course, enrollment_state=enrollment_state):
            yield item

    async def get_assignments(self, course_id: int, bucket: str = "upcoming") -> AsyncIterator[Assignment]:
        endpoint = f"/api/v1/courses/{course_id}/assignments"
        async for item in self._get_iterator(endpoint, Assignment, bucket=bucket):
            yield item

    async def get_notifications(self, per_page: int = 10) -> AsyncIterator[Notification]:
        """Get user's activity stream notifications"""
        endpoint = "/api/v1/users/self/activity_stream"
        async for item in self._get_iterator(endpoint, Notification, per_page=per_page):
            yield item

    async def get_announcements(self, context_codes: list[str] | None = None, per_page: int = 10) -> AsyncIterator[Announcement]:
        """Get announcements for the current user

        Args:
            context_codes: Optional list of context codes (e.g., ['course_123', 'course_456'])
            per_page: Number of announcements to return per page
        """
        endpoint = "/api/v1/announcements"
        kwargs = {"per_page": per_page}
        if context_codes:
            kwargs["context_codes[]"] = context_codes
        async for item in self._get_iterator(endpoint, Announcement, **kwargs):
            yield item

    async def get_user_todos(self) -> AsyncIterator[TodoItem]:
        """Get the current user's todo items"""
        endpoint = "/api/v1/users/self/todo"
        async for item in self._get_iterator(endpoint, TodoItem):
            yield item

    async def get_missing_submissions(self, user_id: str = "self") -> AsyncIterator[Assignment]:
        """Get missing submissions for a user

        Args:
            user_id: User ID or 'self' for the current user
        """
        endpoint = f"/api/v1/users/{user_id}/missing_submissions"
        async for item in self._get_iterator(endpoint, Assignment):
            yield item

    async def get_upcoming_events(self) -> AsyncIterator[UpcomingEvent]:
        """Get upcoming events for the current user"""
        endpoint = "/api/v1/users/self/upcoming_events"
        async for item in self._get_iterator(endpoint, UpcomingEvent):
            yield item


async def main() -> None:
    try:
        settings = Settings()
        async with CanvasClient(settings) as client:
            # Test user todos
            print("=== TODO ITEMS ===")
            async for todo in client.get_user_todos():
                print(f"[{todo.type}] {todo.assignment.name if todo.assignment else 'N/A'}")
                print(f"  URL: {todo.html_url}")
                if todo.needs_grading_count:
                    print(f"  Needs grading: {todo.needs_grading_count}")
                print()

            # Test missing submissions
            print("\n=== MISSING SUBMISSIONS ===")
            async for assignment in client.get_missing_submissions():
                print(f"{assignment.name}")
                print(f"  Due: {assignment.due_at}")
                print()

            # Test upcoming events
            print("\n=== UPCOMING EVENTS ===")
            async for event in client.get_upcoming_events():
                print(f"{event.title}")
                print(f"  Start: {event.start_at}")
                print(f"  Context: {event.context_code}")
                if event.assignment:
                    print(f"  Assignment: {event.assignment.name}")
                print()

            # Test notifications
            print("\n=== NOTIFICATIONS ===")
            async for notification in client.get_notifications(per_page=5):
                print(f"[{notification.type}] {notification.title}")
                print(f"  Created: {notification.created_at}")
                print()

            # Get courses first to use as context for announcements
            courses = [course async for course in client.get_courses()]
            context_codes = [f"course_{course.id}" for course in courses]

            # Test announcements with course context codes
            print("\n=== ANNOUNCEMENTS ===")
            async for announcement in client.get_announcements(context_codes=context_codes, per_page=5):
                print(f"{announcement.title}")
                print(f"  Posted: {announcement.posted_at}")
                print(f"  Read: {announcement.read_state}")
                print()

            # Test courses and assignments
            print("\n=== COURSES & ASSIGNMENTS ===")
            for course in courses:
                print(f"{course.name} (ID: {course.id})")
                async for assignment in client.get_assignments(course.id):
                    print(f"\t{assignment.name} {assignment.due_at}")
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    asyncio.run(main())
